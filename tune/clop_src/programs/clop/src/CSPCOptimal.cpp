/////////////////////////////////////////////////////////////////////////////
//
// CSPCOptimal.cpp
//
// RÃ©mi Coulom
//
// July, 2009
//
/////////////////////////////////////////////////////////////////////////////
#include "CSPCOptimal.h"
#include "CPQuadratic1D.h"
#include "CPFQuadratic.h"

#include <cmath>

/////////////////////////////////////////////////////////////////////////////
// Constructor from CPQuadratic1D
/////////////////////////////////////////////////////////////////////////////
CSPCOptimal::CSPCOptimal(const CPQuadratic1D &q1d):
 Alpha(q1d.GetAlpha()),
 Beta(q1d.GetBeta()),
 Mu(q1d.GetMu()),
 s(std::sqrt(Solve() / Beta)),
 N(0),
 v(1)
{
}

/////////////////////////////////////////////////////////////////////////////
// Constructor from CPFQuadratic
/////////////////////////////////////////////////////////////////////////////
CSPCOptimal::CSPCOptimal(const double *vParam):
 Alpha(vParam[0] - vParam[1] * vParam[1] / (4.0 * vParam[2])),
 Beta(vParam[2]),
 Mu(-vParam[1] / (2.0 * vParam[2])),
 s(std::sqrt(Solve() / Beta)),
 N(0),
 v(1)
{
}

/////////////////////////////////////////////////////////////////////////////
// f
/////////////////////////////////////////////////////////////////////////////
double CSPCOptimal::f(double x) const
{
 double y = std::exp(Alpha + x);
 return (y + 1.0) / (y - 1.0) - x;
}

/////////////////////////////////////////////////////////////////////////////
// Derivative of f
/////////////////////////////////////////////////////////////////////////////
double CSPCOptimal::fprime(double x) const
{
 double y = std::exp(Alpha + x);
 return -2.0 * y / ((y - 1.0) * (y - 1.0)) - 1.0;
}

/////////////////////////////////////////////////////////////////////////////
// Find the negative root of f
/////////////////////////////////////////////////////////////////////////////
double CSPCOptimal::Solve() const
{
 double x = -Alpha - 1.0;

 while (f(x) > 0)
  x = (x - Alpha) * 0.5;

 while (true)
 {
  double y = f(x);
  if (y > -1e-10)
   break;
  x -= y / fprime(x);
 }

 return x;
}

/////////////////////////////////////////////////////////////////////////////
// Get Sample
/////////////////////////////////////////////////////////////////////////////
const double *CSPCOptimal::NextSample(int i)
{
 if (++N & 1)
  v[0] = Mu + s;
 else
  v[0] = Mu - s;

 if (v[0] > 1.0)
  v[0] = 1.0;
 if (v[0] < -1.0)
  v[0] = 1.0;

 return &v[0];
}
